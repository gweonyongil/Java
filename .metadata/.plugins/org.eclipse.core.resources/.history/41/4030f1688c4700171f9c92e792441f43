package view;

import java.awt.Color;
import java.util.ArrayList;

import javax.swing.JTextArea;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultHighlighter;
import javax.swing.text.Document;
import javax.swing.text.Highlighter;

import model.compare.ComparedLine;
import model.compare.Line;

import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class Text extends JTextPane
{
	private ArrayList<LineColorOffset> linecolorlist;
	private Highlighter hilite;
	private Document doc;//getDocument()통해서 초기화
	private DefaultHighlightPainter yellowPainter = new DefaultHighlighter.DefaultHighlightPainter(Color.YELLOW);
	private DefaultHighlightPainter grayPainter = new DefaultHighlighter.DefaultHighlightPainter(Color.GRAY);
	private DefaultHighlightPainter redPainter = new DefaultHighlighter.DefaultHighlightPainter(Color.RED);
	
	//File path needed
	public Text()
	{
		hilite = new MyHighlighter();
		setHighlighter(hilite); 
		//Test
		setText("Line1\n\n\n\nLine2\nLine3\nLine4\nLine5\n");
		//
	}
	
	public Text acceptLineColor(ArrayList<Line> arraylist)
	{
		hilite.removeAllHighlights();
		linecolorlist = new ArrayList<LineColorOffset>();
		try 
		{
			doc = this.getDocument();
			int start = 0;
			int gray_color = 0;
			int yellow_color = 0;
			int linecoloroffset_index = 0;
			
			ComparedLine comparedline;
			for(int i = 0; i < arraylist.size() ; i ++)
			{
				comparedline = (ComparedLine)arraylist.get(i);
				if(comparedline.tag.equals(ComparedLine.Tag.space))
				{
					hilite.addHighlight(start, start + comparedline.line.length(), grayPainter);
					if(gray_color == 0 && yellow_color == 0)
						linecolorlist.add(new LineColorOffset(start));
					if(yellow_color == 1){
						linecolorlist.get(linecoloroffset_index).setEnd(start + start + comparedline.line.length());
						linecolorlist.add(new LineColorOffset(start));
						linecoloroffset_index = i;
						yellow_color = 0;
					}
					if(gray_color == 1)
					{
						linecolorlist.get(linecoloroffset_index).addSameline();
					}
					gray_color = 1;
				}
				else if(comparedline.tag.equals(ComparedLine.Tag.notequal))
				{
					hilite.addHighlight(start, start + comparedline.line.length(), yellowPainter);
					if(gray_color == 0 && yellow_color == 0)
						linecolorlist.add(new LineColorOffset(start));
					if(gray_color == 1){
						linecolorlist.get(linecoloroffset_index).setEnd(start + start + comparedline.line.length());
						linecolorlist.add(new LineColorOffset(start));
						linecoloroffset_index = i;
						gray_color = 0;
					}
					if(yellow_color == 1)
					{
						linecolorlist.get(linecoloroffset_index).addSameline();
					}
					yellow_color = 1;
				}
				if(i == arraylist.size() - 1 &&(gray_color == 1 || yellow_color == 1))
				{
					linecolorlist.get(linecoloroffset_index).setEnd(start + comparedline.line.length());
				}
				start += comparedline.line.length() + 1;
			}
		}
		catch (BadLocationException e) {
			e.printStackTrace();
		}
		return this;
	}
	//툴바 버튼을 통해서 선택된 라인의 집합을 Red로 색상 전환	
	public void selectLineSet(int index) throws BadLocationException
	{
		hilite.removeAllHighlights();
		for(int i = 0; i < linecolorlist.size(); i++)
		{
			if(i != index){
				hilite.addHighlight(linecolorlist.get(i).getStart() ,linecolorlist.get(i).getEnd(), yellowPainter);
			}
		}
		hilite.addHighlight(linecolorlist.get(index).getStart() ,linecolorlist.get(index).getEnd(), redPainter);
	}
	public ArrayList<LineColorOffset> getLineColorList()
	{
		return linecolorlist;
	}
}
//색칠된 구간의 위치를 저장
class LineColorOffset
{
	private int start;
	private int end;
	private int sameline = 0;
	
	public LineColorOffset(int start)
	{
		this.start = start;
	}
	public void setEnd(int end)
	{
		this.end = end;
	}
	public int getStart()
	{
		return start;
	}
	public int getEnd() 
	{
		return end;
	}
	public void addSameline()
	{
		sameline += 1;
	}
}
